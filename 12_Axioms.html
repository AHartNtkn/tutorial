<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Theorem Proving in Lean</title>
<!-- 2015-04-09 Thu 09:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-Axioms" class="outline-2">
<h2 id="Axioms"><a id="sec-1" name="sec-1"></a><span class="section-number-2"> 12</span> Axioms</h2>
<div class="outline-text-2" id="text-Axioms">

<p>
We have seen that the version of the Calculus of Inductive
Constructions that has been implemented in Lean includes a nested
hierarchy of universes with an impredicative, proof-irrelevant <code>Prop</code>
at the bottom, Pi types, and inductive types. In this chapter, we
consider extensions of the CIC with additional axioms and
rules. Extending a foundational system in such a way is often
convenient; it can make it possible to prove more theorems, as well as
easier to prove theorems that could have been proved otherwise. But
often there are also negative consequences of adding additional axioms
that go beyond questions of soundness and correctness.
</p>

<p>
Lean's standard library makes available a number of "classical"
axioms, which are justified on a set-theoretic interpretation of type
theory. But these axioms are at odds with a constructive
interpretation of the system, as well as its computational
behavior. When you import the standard library, most of these axioms
are therefore not imported by default.
</p>

<p>
The standard library does, however, make use of two mildly classical
axioms, namely, propositional extensionality and quotients. Their use
in core parts of the standard library is still provisional, and may be
curtailed if it proves to have sufficiently bad computational
effects. The next section aims to clarify some of the issues and
concerns.
</p>

<p>
[Note: parts of this chapter are still under construction.]
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3"> 12.1</span> Computation and Axioms</h3>
<div class="outline-text-3" id="text-1-1">
<p>
For most of its history, mathematics was essentially computational:
geometry dealt with constructions of geometric objects, algebra was
concerned with algorithmic solutions to systems of equations, and
analysis provided to means to compute the future behavior of systems
evolving over time. From the proof of a theorem to the effect that
"for every <code>x</code>, there is a <code>y</code> such that &#x2026;" is was generally
straightforward to extract an algorithm to compute such a <code>y</code> given
<code>x</code>.
</p>

<p>
In the nineteenth century, however, increases in the complexity of
mathematical arguments pushed mathematicians to develop new styles of
reasoning that suppress algorithmic information, and invoke
descriptions of mathematical objects that abstract away the details of
how those objects are represented. The goal was to obtain a powerful
"conceptual" understanding without getting bogged down in
computational details, but this had the effect of admitting
mathematical theorems that are simply <i>false</i> on a direct
computational reading.
</p>

<p>
There is still fairly uniform agreement today that computation is
important to mathematics. But there are different views as to how best
to address computational concerns. From a <i>constructive</i> point of
view, it is a mistake to separate mathematics from its computational
roots; every meaningful mathematical theorem should have a direct
computational interpretation. From a <i>classical</i> point of view, it is
more fruitful to maintain a separation of concerns: we can use one
language and body of methods to write computer programs, while
maintaining the freedom to use a nonconstructive theories and methods
to reason about them.
</p>

<p>
Lean is designed to support both of these approaches. Core parts of
the library are developed constructively, but the system also provides
support for carrying out classical mathematical reasoning.
</p>

<p>
Computationally, the "purest" part of dependent type theory avoids the
use of <code>Prop</code> entirely. Inductive types and Pi types can be viewed as
data types, and terms of these types can be "evaluated" by applying
reduction rules until no more rules can be applied. In principle, any
closed term (that is, term with no free variables) of type <code>ℕ</code> should
evaluate to a numeral, <code>succ (succ (succ ... 0))</code>.
</p>

<p>
Introducing a proof-irrelevant <code>Prop</code> and marking theorems opaque
represents a first step towards separation of concerns. The intention
is that elements of a type <code>P : Prop</code> should play no role in
computation, and so the particular construction of a term <code>t : P</code> is
"irrelevant" in that sense. One can still define computational objects
the incorporate elements of type <code>Prop</code>; the point is that these
elements can help us reason about the effects of the computation, but
can be ignored when we extract "code" from the term. Elements of type
<code>Prop</code> are not entirely innocuous, however. They include equations <code>s
= t : A</code> for any type <code>A</code>, and such equations can be used as casts, to
type check terms.
</p>

<p>
Having adopted a proof-irrelevant <code>Prop</code>, one might consider it
legitimate to add arbitrary classical axioms, such as the law of the
excluded middle, governing propositions. From a constructive point of
view, the most objectionable classical axioms are "choice axioms" that
allow us to extract "data" from any existential proposition,
completely erasing the distinction between the proof-irrelevant and
data-relevant parts of the theory. These are discussed in Section
<a href="#" onclick="myModule.scrollTutorialTo('Choice_Axioms')">Choice Axioms</a> below.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3"> 12.2</span> Propositional Extensionality</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Propositional extensionality is the following axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">axiom propext {a b : Prop} : a ↔ b → a = b</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>namespace hide

axiom propext {a b : Prop} : a ↔ b → a = b

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It asserts that when two propositions imply one another, they are
actually equal. This is consistent with set-theoretic
interpretations in which any element <code>a : Prop</code> is either empty or the
singleton set <code>{*}</code>, for some distinguished element <code>*</code>. The axiom has
the the effect that equivalent propositions can be substituted for one
another in any context:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">section
  open eq.ops
  variables a b c d e : Prop
  variable P : Prop → Prop

  example (H : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext H ▸ !iff.refl

  example (H : a ↔ b) (H1 : P a) : P b :=
  propext H ▸ H1
end</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>namespace hide

axiom propext {a b : Prop} : a ↔ b → a = b

section
  open eq.ops
  variables a b c d e : Prop
  variable P : Prop → Prop

  example (H : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext H ▸ !iff.refl

  example (H : a ↔ b) (H1 : P a) : P b :=
  propext H ▸ H1
end

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first example could be proved more laboriously without <code>propext</code>
using the fact that the propositional connectives respect
propositional equivalence. The second example represents a more
essential use of <code>propext</code>. In fact, it is equivalent to <code>propext</code>
itself, a fact which we encourage you to prove.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3"> 12.3</span> Function Extensionality</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Similar to propositional extensionality, function extensionality is
the following axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">axiom funext {A : Type} {B : A → Type} {f₁ f₂ : Πx : A, B x} :
(∀x, f₁ x = f₂ x) → f₁ = f₂</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>namespace hide

axiom funext {A : Type} {B : A → Type} {f₁ f₂ : Πx : A, B x} :
(∀x, f₁ x = f₂ x) → f₁ = f₂
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It asserts that any two functions of type <code>Πx : A, B x</code> that agree on
all their inputs are equal. From a classical, set-theoretic
perspective, this is exactly what it means for two functions to be
equal. This is known as an "extensional" view of functions. From a
constructive perspective, however, it is sometimes more natural to
think of functions as algorithms, or computer programs, that are
presented in some explicit way. It is certainly the case that two
computer programs can compute the same answer for every input despite
the fact that they are syntactically quite different. In much the same
way, you might want to maintain a view of functions that does not
force you to identify two functions that have the same intput / output
behavior. This is known as an "intensional" view of
functions. Adopting <code>funext</code> commits us to an extensional view of
functions.
</p>

<p>
Suppose that for <code>X : Type</code> we define the <code>set X := X → Prop</code> to
denote the type of subsets of <code>X</code>, essentially identifying subsets
with predicates. By combining <code>funext</code> and <code>propext</code>, we obtain an
extensional theory of such sets:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">definition set (X : Type) := X → Prop

namespace set

variable {X : Type}

definition mem [reducible] (x : X) (a : set X) := a x
notation e ∈ a := mem e a

theorem setext {a b : set X} (H : ∀x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (H x))

end set</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>import logic
open eq.ops

namespace hide

definition set (X : Type) := X → Prop

namespace set

variable {X : Type}

definition mem [reducible] (x : X) (a : set X) := a x
notation e ∈ a := mem e a

theorem setext {a b : set X} (H : ∀x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (H x))

end set
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can then proceed to define the empty set and set intersection, for
example, and prove set identities:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">definition empty [reducible] : set X := λx, false
notation `∅` := empty

definition inter [reducible] (a b : set X) : set X := λx, x ∈ a ∧ x ∈ b
notation a ∩ b := inter a b

theorem inter_self (a : set X) : a ∩ a = a :=
setext (take x, !and_self)

theorem inter_empty (a : set X) : a ∩ ∅ = ∅ :=
setext (take x, !and_false)

theorem empty_inter (a : set X) : ∅ ∩ a = ∅ :=
setext (take x, !false_and)

theorem inter.comm (a b : set X) : a ∩ b = b ∩ a :=
setext (take x, !and.comm)</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>import standard
import logic
open eq.ops

namespace hide

definition set (X : Type) := X → Prop

namespace set

variable {X : Type}

definition mem [reducible] (x : X) (a : set X) := a x
notation e ∈ a := mem e a

theorem setext {a b : set X} (H : ∀x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (H x))

definition empty [reducible] : set X := λx, false
notation `∅` := empty

definition inter [reducible] (a b : set X) : set X := λx, x ∈ a ∧ x ∈ b
notation a ∩ b := inter a b

theorem inter_self (a : set X) : a ∩ a = a :=
setext (take x, !and_self)

theorem inter_empty (a : set X) : a ∩ ∅ = ∅ :=
setext (take x, !and_false)

theorem empty_inter (a : set X) : ∅ ∩ a = ∅ :=
setext (take x, !false_and)

theorem inter.comm (a b : set X) : a ∩ b = b ∩ a :=
setext (take x, !and.comm)

end set
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>


<p>
In fact, function extensionality follows from the existence of
quotients, which we describe in the next section. In the Lean standard
library, therefore, <code>funext</code> is thus proved from the quotient
construction.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3"> 12.4</span> Quotients</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Let <code>A</code> be any type, and let <code>R</code> be an equivalence relation on <code>A</code>. It
is mathematically common to form the "quotient" <code>A / R</code>, that is, the
type of elements of <code>A</code> "modulo" <code>R</code>. Set theoretically, one can view
<code>A / R</code> as the set of equivalence classes of <code>A</code> modulo <code>R</code>. If <code>f : A
→ B</code> is any function that respects the equivalence relation in the
sense that for every <code>x y : A</code>, <code>R x y</code> implies <code>f x = f y</code>, then <code>f</code>
"lifts" to a function <code>f' : A / R → B</code> defined on each equivalence
class <code>[x]</code> by <code>f' [x] = f x</code>. Lean's standard library extends the CIC
with additional contants that perform exactly these constructions, and
installs this last equation as a definitional reduction rule.
</p>

<p>
First, it is useful to define the notion of a <i>setoid</i>, which is
simply a type with an associated equivalence relation:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">structure setoid [class] (A : Type) :=
(r : A → A → Prop) (iseqv : equivalence r)

namespace setoid
  infix `≈` := setoid.r

  variable {A : Type}
  variable [s : setoid A]
  include s

  theorem refl (a : A) : a ≈ a :=
  and.elim_left (@setoid.iseqv A s) a

  theorem symm {a b : A} : a ≈ b → b ≈ a :=
  λ H, and.elim_left (and.elim_right (@setoid.iseqv A s)) a b H

  theorem trans {a b c : A} : a ≈ b → b ≈ c → a ≈ c :=
  λ H₁ H₂, and.elim_right (and.elim_right (@setoid.iseqv A s)) a b c H₁ H₂
end setoid</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>namespace hide

structure setoid [class] (A : Type) :=
(r : A → A → Prop) (iseqv : equivalence r)

namespace setoid
  infix `≈` := setoid.r

  variable {A : Type}
  variable [s : setoid A]
  include s

  theorem refl (a : A) : a ≈ a :=
  and.elim_left (@setoid.iseqv A s) a

  theorem symm {a b : A} : a ≈ b → b ≈ a :=
  λ H, and.elim_left (and.elim_right (@setoid.iseqv A s)) a b H

  theorem trans {a b c : A} : a ≈ b → b ≈ c → a ≈ c :=
  λ H₁ H₂, and.elim_right (and.elim_right (@setoid.iseqv A s)) a b c H₁ H₂
end setoid

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Given a type <code>A</code>, a relation <code>R</code> on <code>A</code>, and a proof <code>p</code> that <code>R</code> is
an equivalence relation, we can define <code>setoid.mk p</code> as an instance of
the setoid class. Lean's type class inference mechanism then allows us
to use the generic notation <code>≈</code> for <code>R</code>, and to use the generic theorems
<code>setoid.refl</code>, <code>setoid.symm</code>, <code>setoid.trans</code> to reason about <code>R</code>.
</p>

<p>
The quotient package consists of the following constructors:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">open setoid
constant quot.{l}   : Π {A : Type.{l}}, setoid A → Type.{l}

namespace quot
  constant mk        : Π {A : Type}   [s : setoid A], A → quot s
  notation `⟦`:max a `⟧`:0 := mk a

  constant sound     : Π {A : Type}   [s : setoid A] {a b : A}, a ≈ b → ⟦a⟧ = ⟦b⟧
  constant exact     : Π {A : Type}   [s : setoid A] {a b : A}, ⟦a⟧ = ⟦b⟧ → a ≈ b
  constant lift      : Π {A B : Type} [s : setoid A] (f : A → B), (∀ a b, a ≈ b → f a = f b) → quot s → B
  constant ind       : ∀ {A : Type}   [s : setoid A] {B : quot s → Prop}, (∀ a, B ⟦a⟧) → ∀ q, B q
end quot</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>namespace hide

open setoid
constant quot.{l}   : Π {A : Type.{l}}, setoid A → Type.{l}

namespace quot
  constant mk        : Π {A : Type}   [s : setoid A], A → quot s
  notation `⟦`:max a `⟧`:0 := mk a

  constant sound     : Π {A : Type}   [s : setoid A] {a b : A}, a ≈ b → ⟦a⟧ = ⟦b⟧
  constant exact     : Π {A : Type}   [s : setoid A] {a b : A}, ⟦a⟧ = ⟦b⟧ → a ≈ b
  constant lift      : Π {A B : Type} [s : setoid A] (f : A → B), (∀ a b, a ≈ b → f a = f b) → quot s → B
  constant ind       : ∀ {A : Type}   [s : setoid A] {B : quot s → Prop}, (∀ a, B ⟦a⟧) → ∀ q, B q
end quot

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>
<p>
For any type <code>A</code> with associated equivalence relation <code>R</code>, first we
declare a setoid instance <code>s</code> to associate <code>R</code> as "the" equivalence
relation on <code>A</code>. Once we do that, <code>quot s</code> denotes the quotient type
<code>A / R</code>, and given <code>a : A</code>, <code>⟦a⟧</code> denotes the "equivalence class" of
<code>a</code>. The meaning of constants <code>sound</code>, <code>exact</code>, <code>lift</code>, and <code>ind</code> are
given by their types. In particular, <code>lift</code> is the function which
lifts a function <code>f : A → B</code> that respects the equivalence relation to
the function <code>lift f : quot s → B</code> which lifts <code>f</code> to <code>A / R</code>. After
declaring the constants associated with the quotient type, the library
file then calls an internal function, <code>init_quotient</code>, which installs
the reduction that simplifies <code>lift f ⟦a⟧</code> to <code>f a</code>.
</p>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3"> 12.5</span> Excluded Middle</h3>
<div class="outline-text-3" id="text-1-5">
<p>
The law of the excluded middle is the following:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">axiom em (a : Prop) : a ∨ ¬a</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>namespace hide
axiom em (a : Prop) : a ∨ ¬a
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can import this axiom with <code>import logic.axioms.em</code>. It is
automatically imported by <code>import logic.axioms.classical</code>, or,
more simply, <code>import classical</code>.
</p>

<p>
The law of the excluded middle implies propositional completeness:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">theorem prop_complete (a : Prop) : a = true ∨ a = false :=
or.elim (em a)
  (λ t, or.inl (propext (iff.intro (λ h, trivial) (λ h, t))))
  (λ f, or.inr (propext (iff.intro (λ h, absurd h f) (λ h, false.elim h))))</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>import logic.axioms.em

namespace hide

theorem prop_complete (a : Prop) : a = true ∨ a = false :=
or.elim (em a)
  (λ t, or.inl (propext (iff.intro (λ h, trivial) (λ h, t))))
  (λ f, or.inr (propext (iff.intro (λ h, absurd h f) (λ h, false.elim h))))

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-Choice_Axioms" class="outline-3">
<h3 id="Choice_Axioms"><a id="sec-1-6" name="sec-1-6"></a><span class="section-number-3"> 12.6</span> Choice Axioms</h3>
<div class="outline-text-3" id="text-Choice_Axioms">

<p>
The last of the classical axioms we consider is the following choice
axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">axiom strong_indefinite_description {A : Type} (P : A → Prop) (H : nonempty A) :
  { x | (∃y : A, P y) → P x}</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>import data.subtype
open subtype nonempty

namespace hide
axiom strong_indefinite_description {A : Type} (P : A → Prop) (H : nonempty A) :
  { x | (∃y : A, P y) → P x}
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This asserts that given any predicate <code>P</code> on a nonempty type <code>A</code>, we
can (magically) produce an element <code>x</code> with the property that if any
element of <code>A</code> satisfies <code>P</code>, then <code>x</code> does. In the presence of
classical logic, we could prove this from the slighly weaker axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">axiom indefinite_description {A : Type} {P : A → Prop} (H : ∃x, P x) :
  {x : A | P x}</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>import data.subtype
open subtype nonempty

namespace hide
axiom indefinite_description {A : Type} {P : A → Prop} (H : ∃x, P x) :
  {x : A | P x}
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This says that knowing that there is an element of <code>A</code> satisfying <code>P</code>
is enough to produce one. This axiom essentially undoes the separation
of data from propositions, because it allows us to extract a piece of
data &#x2014; an element of <code>A</code> satisfying <code>P</code> &#x2014; from the proposition
that such an element exists.
</p>

<p>
The axiom <code>strong_indefinite_description</code> is imported when you import
the classical axioms. Separating the <code>x</code> asserted to exist by the
axiom from the property it satisfies allows us to define the Hilbert
epsilon function:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">opaque definition epsilon {A : Type} [H : nonempty A] (P : A → Prop) : A :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
elt_of u

theorem epsilon_spec_aux {A : Type} (H : nonempty A) (P : A → Prop) (Hex : ∃y, P y) :
    P (@epsilon A H P) :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
has_property u Hex

theorem epsilon_spec {A : Type} {P : A → Prop} (Hex : ∃y, P y) :
    P (@epsilon A (nonempty_of_exists Hex) P) :=
epsilon_spec_aux (nonempty_of_exists Hex) P Hex</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>import data.subtype
open subtype nonempty

namespace hide

axiom strong_indefinite_description {A : Type} (P : A → Prop) (H : nonempty A) :
  { x | (∃y : A, P y) → P x}

opaque definition epsilon {A : Type} [H : nonempty A] (P : A → Prop) : A :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
elt_of u

theorem epsilon_spec_aux {A : Type} (H : nonempty A) (P : A → Prop) (Hex : ∃y, P y) :
    P (@epsilon A H P) :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
has_property u Hex

theorem epsilon_spec {A : Type} {P : A → Prop} (Hex : ∃y, P y) :
    P (@epsilon A (nonempty_of_exists Hex) P) :=
epsilon_spec_aux (nonempty_of_exists Hex) P Hex

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Assuming the type <code>A</code> is nonempty, <code>epsilon P</code> returns an element of
<code>A</code>, with the property that if any element of <code>A</code> satisfies <code>P</code>,
<code>epsilon P</code> does.
</p>

<p>
Just as <code>indefinite_description</code> is a weaker version of
<code>strong_indefinite_description</code>, the <code>some</code> operator is a weaker
version of the <code>epsilon</code> operator. It is sometimes easier to
use. Assuming <code>H : ∃x, P x</code> is a proof that some element of <code>A</code>
satisfies <code>P</code>, <code>some H</code> denotes such an element.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">definition some {A : Type} {P : A → Prop} (H : ∃x, P x) : A :=
@epsilon A (nonempty_of_exists H) P

theorem some_spec {A : Type} {P : A → Prop} (H : ∃x, P x) : P (some H) :=
epsilon_spec H</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>import data.subtype
open subtype nonempty

namespace hide

axiom strong_indefinite_description {A : Type} (P : A → Prop) (H : nonempty A) :
  { x | (∃y : A, P y) → P x}

opaque definition epsilon {A : Type} [H : nonempty A] (P : A → Prop) : A :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
elt_of u

theorem epsilon_spec_aux {A : Type} (H : nonempty A) (P : A → Prop) (Hex : ∃y, P y) :
    P (@epsilon A H P) :=
let u : {x | (∃y, P y) → P x} :=
  strong_indefinite_description P H in
has_property u Hex

theorem epsilon_spec {A : Type} {P : A → Prop} (Hex : ∃y, P y) :
    P (@epsilon A (nonempty_of_exists Hex) P) :=
epsilon_spec_aux (nonempty_of_exists Hex) P Hex

definition some {A : Type} {P : A → Prop} (H : ∃x, P x) : A :=
@epsilon A (nonempty_of_exists H) P

theorem some_spec {A : Type} {P : A → Prop} (H : ∃x, P x) : P (some H) :=
epsilon_spec H

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In Section <a href="#" onclick="myModule.loadTutorial('08_Building_Theories_and_Proofs.html', 'Making_Auxiliary_Facts_Visible')">Making Auxiliary Facts Visible</a>, we explained that, on some
occasions, it is necessary to use <code>assert</code> instead of <code>have</code> to put
auxiliary goals into the context so that the elaborator can find
them. This often comes up in connection to <code>epsilon</code> and <code>some</code>,
because these induce dependencies on elements of <code>Prop</code>. The following
examples illustrate some of the places where <code>assert</code> is needed. A
good rule of thumb is that if you are using <code>some</code> or <code>epsilon</code>, and
you are presented with a strange error message, trying changing <code>have</code>
to <code>assert</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">import logic.axioms.hilbert

section
  variable A : Type
  variable a : A

  -- o.k.
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) H2

  /-
  -- invalid local context
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro _ H2
  -/

  -- o.k.
  example : ∃x : A, x = x :=
  assert H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro _ H2

  /-
  -- invalid local context
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) (eq.trans H2 H2)
  -/

  -- o.k.
  example : ∃x : A, x = x :=
  assert H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) (eq.trans H2 H2)
end
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>import logic.axioms.hilbert

section
  variable A : Type
  variable a : A

  -- o.k.
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) H2

  /-
  -- invalid local context
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro _ H2
  -/

  -- o.k.
  example : ∃x : A, x = x :=
  assert H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro _ H2

  /-
  -- invalid local context
  example : ∃x : A, x = x :=
  have H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) (eq.trans H2 H2)
  -/

  -- o.k.
  example : ∃x : A, x = x :=
  assert H1 : ∃y, y = y, from exists.intro a rfl,
  have H2 : some H1 = some H1, from some_spec H1,
  exists.intro (some H1) (eq.trans H2 H2)
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3"> 12.7</span> Propositional Decidability</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Taken together, the law of the excluded middle and the axiom of indefinite description
imply that every proposition is decidable. The following is the
contained in <code>logic.axioms.prop_decidable</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">theorem decidable_inhabited [instance] (a : Prop) : inhabited (decidable a) :=
inhabited_of_nonempty
  (or.elim (em a)
    (assume Ha, nonempty.intro (inl Ha))
    (assume Hna, nonempty.intro (inr Hna)))

theorem prop_decidable [instance] (a : Prop) : decidable a :=
arbitrary (decidable a)</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>import logic.axioms.prop_complete logic.axioms.hilbert
open decidable inhabited nonempty

namespace hide

theorem decidable_inhabited [instance] (a : Prop) : inhabited (decidable a) :=
inhabited_of_nonempty
  (or.elim (em a)
    (assume Ha, nonempty.intro (inl Ha))
    (assume Hna, nonempty.intro (inr Hna)))

theorem prop_decidable [instance] (a : Prop) : decidable a :=
arbitrary (decidable a)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The theorem <code>decidable_inhabited</code> uses the law of the excluded middle
to show that <code>decidable a</code> is inhabited for any <code>a</code>. It is marked as
an instance, and is silently used for for synthesizing the implicit
argument in <code>arbitrary (decidable a)</code>.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
